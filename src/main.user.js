// ==UserScript==
// @name        WhatsApp Group Members Extractor
// @namespace   Violentmonkey Scripts
// @match       https://web.whatsapp.com/*
// @grant       GM_registerMenuCommand
// @version     1.0.0
// @author      Thiago Navarro
// @run-at      document-end
// @description Extracts all group members by just pressing `F2` with a open group in WhatsApp web!
// @downloadURL https://git.ozzuu.com/thisago/wppGroupMembers/raw/branch/master/src/main.user.js
// ==/UserScript==

let panicStop = false
function ifPanicStop() {
  if (panicStop) {
    console.log("Panic stop")
    return true
  }
  return false
}
/**
 * Simulates a human-like click interaction on an element using mouse events.
 *
 * Generated by ChatGPT:
 *
 * @param {HTMLElement} element - The element to be clicked.
 * @param {number} minDelay - The minimum delay before the click (in milliseconds).
 * @param {number} maxDelay - The maximum delay before the click (in milliseconds).
 */
async function simulateHumanLikeClick(element, minDelay = 200, maxDelay = 300) {
  if (element) {
    const randomDelay1 = Math.random() * (maxDelay - minDelay) + minDelay
    const randomDelay2 = Math.random() * (maxDelay - minDelay) + minDelay

    const clickX = element.getBoundingClientRect().left + Math.random() * 20 + 5
    const clickY = element.getBoundingClientRect().top + Math.random() * 20 + 5

    await sleep(randomDelay1)

    element.dispatchEvent(
      new MouseEvent("mouseover", {
        bubbles: true,
        cancelable: true,
        view: unsafeWindow,
      })
    )

    await sleep(randomDelay2)

    element.dispatchEvent(
      new MouseEvent("mousedown", {
        bubbles: true,
        cancelable: true,
        view: unsafeWindow,
        clientX: clickX,
        clientY: clickY,
      })
    )

    await sleep(randomDelay1 + randomDelay2 / 3)

    element.dispatchEvent(
      new MouseEvent("mouseup", {
        bubbles: true,
        cancelable: true,
        view: unsafeWindow,
        clientX: clickX,
        clientY: clickY,
      })
    )
  } else {
    console.log("Element not found")
  }
}

const sleep = (ms) => new Promise((r) => setTimeout(r, ms))

/**
 * Waits a element
 *
 * @param {Element} baseEl Element to run querySelector
 * @param {string} selector CSS element selector
 * @param {Function} check Check if can run `cb`
 * @param {number} checkInterval Time in ms to check if element exists
 * @param {number} limit Max checks
 *
 * @returns {Promise<Element>}
 */
function waitEl(
  baseEl,
  selector,
  limit = 30,
  check = (el) => el != null,
  checkInterval = 1000
) {
  return new Promise((resolve, reject) => {
    const interval = setInterval(() => {
      if (limit == 0 || panicStop) {
        clearInterval(interval)
        if (ifPanicStop()) return
        reject(`Cannot find "${selector}", tries limit reached.`)
        return
      }
      let el = baseEl.querySelector(selector)
      if (check(el)) {
        clearInterval(interval)
        resolve(el)
      }
      limit--
    }, checkInterval)
  })
}

/**
 * Remove duplicated numbers
 *
 * @param {Array<Object>} members
 * @returns {Array<Object>}
 */
function dedupMembers(members) {
  const contains = (arr, item) => {
    for (const x of arr) if (x.phone == item.phone) return true

    return false
  }
  let result = []
  members.map((member) => {
    if (!contains(result, member)) result.push(member)
  })
  return result
}

/**
 * Automatically extract members from open group
 *
 * @returns {Promise<Array.>}
 */
function getMembers(sleepBetweenScrollPages = 500) {
  return new Promise(async (resolve, reject) => {
    const openGroupInfoEl = document.querySelector(
      "[data-testid=conversation-info-header]"
    )

    if (!openGroupInfoEl) {
      reject("Button to open group info not found.")
      return
    }

    openGroupInfoEl.click()

    const openGroupParticipantsSel = ".q1n4p668"
    const groupParticipantsSel = "div.thghmljt:nth-child(3)"

    try {
      const openGroupParticipantsEl = await waitEl(
        document,
        openGroupParticipantsSel
      )
      openGroupParticipantsEl.click()
    } catch {
      reject("Cannot find the element to open group participants")
      return
    }

    let groupParticipantsEl = null
    let membersListEl = null
    try {
      groupParticipantsEl = await waitEl(document, groupParticipantsSel)
      membersListEl = groupParticipantsEl.querySelector("._3YS_f._2A1R8")
    } catch {
      reject("Cannot find the group participants element")
      return
    }

    let members = []
    var remainingScrolls = -1 // infinite
    const pageSizeSubtract = 20
    const pageSize = groupParticipantsEl.clientHeight - pageSizeSubtract

    groupParticipantsEl.scrollTop = 0 // reset scroll
    var stop = false
    while (!stop && remainingScrolls != 0) {
      if (ifPanicStop()) break
      stop = !(
        groupParticipantsEl.scrollTop <
        groupParticipantsEl.scrollHeight - (pageSize + pageSizeSubtract)
      )
      try {
        await waitEl(groupParticipantsEl, ".cw3vfol9._11JPr", 100)
      } catch {
        reject("Cannot find the first user bio in participant list")
        break
      }
      ;[...membersListEl.children].forEach((memberEl) => {
        try {
          let member = {
            name:
              memberEl.querySelector(
                ".ggj6brxn.gfz4du6o.r7fjleex.g0rxnol2.lhj4utae.le5p0ye3.l7jjieqr._11JPr"
              )?.innerText ?? "",
            bio:
              memberEl.querySelector(
                ".cw3vfol9._11JPr.selectable-text.copyable-text"
              )?.innerText ?? "",
            avatar: memberEl.querySelector("img")?.src ?? "",
            phone: memberEl.querySelector("span._2h0YP")?.innerText ?? "",
            role: memberEl.querySelector("div.Dvjym")?.innerText ?? "",
          }
          if (!member.phone && member.name && member.name[0] == "+") {
            member.phone = member.name
            member.name = ""
          }
          if (member.role == member.phone) {
            member.role = ""
          }
          members.push(member)
        } catch (err) {
          console.log(err, memberEl)
        }
      })
      await sleep(sleepBetweenScrollPages)
      groupParticipantsEl.scrollTop += pageSize
      remainingScrolls--

      break
    }
    
    await sleep(500)

    // close participants list
    document.querySelector("[data-testid=btn-closer-drawer]").click()
    
    // resolve promise
    resolve(dedupMembers(members))
  })
}

/**
 * Converts json members to csv
 *
 * @param {Array<Object>} members
 * @returns string
 */
function groupMembersToCsv(members) {
  let csv = "phone,name,bio,avatar,role\n"
  members.map((member) => {
    if (!member.phone) return
    csv += `"${member.phone}","${member.name}","${member.bio}","${member.avatar}","${member.role}"\n`
  })
  return csv
}

/**
 * Converts json members object to csv
 *
 * @param {Array<Object>} members
 * @returns string
 */
function allGroupsMembersToCsv(members) {
  let csv = "group,phone,name,bio,avatar,role\n"
  Object.keys(members).map(group => {
    members[group].map((member) => {
      if (!member.phone) return
      csv += `"${group}","${member.phone}","${member.name}","${member.bio}","${member.avatar}","${member.role}"\n`
    })
  })
  return csv
}

/**
 * Download text as blob
 *
 * @param {string} text
 * @param {string} mime
 * @param {string} filename
 */
function download(text, mime = "text/plain", filename = "members.csv") {
  const blob = new Blob([text], {
    type: mime,
  })
  var link = document.createElement("a")
  link.href = URL.createObjectURL(blob)
  if (confirm("Want to download?")) {
    link.download = filename
  } else {
    link.target = "_blank"
  }
  link.click()
}

// trigger
let processing = false
async function extractThisGroup() {
  if (processing) {
    alert("Please wait the finish of previous extraction.")
    return
  }
  processing = true
  try {
    const members = await getMembers()
    download(groupMembersToCsv(members))
  } catch (err) {
    alert(err)
  }
  processing = false
}

async function extractAllGroups() {
  // Containing this string in subheader, it'll be identified as group ready to be extracted
  if (processing) {
    alert("Please wait the finish of previous extraction.")
    return
  }
  const groupIdentifierString = prompt(
    "Provide a string contained in group in subheader to check if it's a group or just a contact (If group contains Brazilian numbers, just confirm)",
    "+55"
  )
  if (!groupIdentifierString) {
    alert("No subheader string check, stopping")
    return
  }
  processing = true
  
  let members = {}

  for (const chat of document.querySelectorAll("._199zF._3j691._1KV7I")) {
    if (ifPanicStop()) break
    await simulateHumanLikeClick(chat)
    try {
      await waitEl(
        document,
        ".g4oj0cdv > span:nth-child(1)",
        15,
        (el) => {
          if (!el) return false
          if (
            el.innerText.indexOf("group") == -1 &&
            el.innerText.indexOf("is typing") == -1 &&
            el.innerText.indexOf(groupIdentifierString) == -1
          )
            return false

          return true
        },
        200
      )
      let groupName = chat.innerText.split("\n")[0].trim()
      console.log("it's a group: ", groupName)
      await sleep(500)
      try {
        members[groupName] = await getMembers()
      } catch (err) {
        if (!confirm(`Error: ${err}\n\nTry next group?`)) break
      }

      await sleep(1000)
    } catch {
      console.log("not group")
    }
  }
  console.log(members)
  download(allGroupsMembersToCsv(members))
  processing = false
}

function doPanicStop() {
  panicStop = true
  setTimeout(() => {
    processing = false
    panicStop = false
  }, 5000)
}

GM_registerMenuCommand("Extract this group", extractThisGroup, "g")
GM_registerMenuCommand("Extract all groups", extractAllGroups, "a")
GM_registerMenuCommand("Stop all actions", doPanicStop, "s")
